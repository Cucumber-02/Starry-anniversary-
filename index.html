<!-- index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pixel Night Ocean</title>
  <style>
    html, body { height: 100%; margin: 0; background: #000; overflow: hidden; }
    canvas {
      width: 100vw;
      height: 100vh;
      display: block;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }

    #catchBtn {
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      padding: 16px 26px;
      font: 700 16px/1.15 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      letter-spacing: 0.2px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.20);
      background: rgba(10, 14, 24, 0.55);
      color: rgba(255,255,255,0.94);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      cursor: pointer;
      user-select: none;
    }
    #catchBtn:hover { background: rgba(18, 24, 40, 0.65); }
    #catchBtn:active { transform: translateX(-50%) translateY(1px); }

    #catchBtn::after{
      content:"";
      position:absolute;
      inset:-2px;
      border-radius: 20px;
      pointer-events:none;
      box-shadow: 0 0 26px rgba(120, 180, 255, 0.18);
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<button id="catchBtn" type="button">Catch a Star</button>

<!-- 1) LINK the separate file -->
<script src="fallingStars.js"></script>

<script>
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });
  ctx.imageSmoothingEnabled = false;

  const catchBtn = document.getElementById("catchBtn");

  // ---------- TWEAK KNOBS ----------
  let PX = 4;
  const SKY_RATIO = 0.62;
  const STAR_COUNT = 110;
  const SHOOTING_CHANCE = 0.06; // meteors keep appearing randomly
  // --------------------------------

  const OCEAN_PAL = [
    "#001027",
    "#00183a",
    "#00234f",
    "#002f66",
    "#003a7a",
    "#0a4a8c",
    "#1f63a8",
    "#63a7ff"
  ];

  function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
  function lerp(a, b, t) { return a + (b - a) * t; }

  function easeInOut(t) {
    t = clamp(t, 0, 1);
    return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3)/2;
  }

  // Hash noise (fast)
  function hash2(x, y) {
    let n = x * 374761393 + y * 668265263;
    n = (n ^ (n >> 13)) * 1274126177;
    n = n ^ (n >> 16);
    return (n >>> 0) / 4294967296;
  }

  function smoothNoise(x, y) {
    const x0 = Math.floor(x), y0 = Math.floor(y);
    const fx = x - x0, fy = y - y0;
    const n00 = hash2(x0, y0);
    const n10 = hash2(x0 + 1, y0);
    const n01 = hash2(x0, y0 + 1);
    const n11 = hash2(x0 + 1, y0 + 1);
    const nx0 = lerp(n00, n10, fx);
    const nx1 = lerp(n01, n11, fx);
    return lerp(nx0, nx1, fy);
  }

  function resize() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width  = Math.floor(window.innerWidth  * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);

    const minDim = Math.min(window.innerWidth, window.innerHeight);
    PX = minDim < 520 ? 5 : 4;
  }
  window.addEventListener("resize", resize);
  resize();

  // --------- CAMERA PAN (downwards = look up) ----------
  let camStartY = 0;
  let camNowY = 0;
  let camTargetY = 0;
  let camT0 = -999;
  const PAN_DURATION = 2.2; // slower shift

  function computePanDownPx(skyH, h) {
    // hide ocean: need skyH + camY >= h
    return (h - skyH) + 24;
  }

  function startPan(nowSeconds, skyH, h) {
    camStartY = camNowY;
    const down = computePanDownPx(skyH, h);
    camTargetY = (Math.abs(camNowY) < 1) ? down : 0; // toggle
    camT0 = nowSeconds;
  }

  // --------- STARFIELD (twinkles) ----------
  const stars = [];
  function initStars() {
    stars.length = 0;

    const w = canvas.width, h = canvas.height;
    const skyH = Math.floor(h * SKY_RATIO);

    const cols = Math.ceil(w / PX);
    const rowsFull = Math.ceil(h / PX);

    // Extend starfield above the canvas so when we pan DOWN, we still see stars at top
    const panDownPx = computePanDownPx(skyH, h);
    const padRows = Math.ceil(panDownPx / PX) + 26;

    const extendedRows = rowsFull + 2 * padRows;

    // density based on "sky rows" baseline
    const skyRows = Math.max(1, Math.ceil(skyH / PX));
    const scaledCount = Math.floor(STAR_COUNT * (extendedRows / skyRows));

    for (let i = 0; i < scaledCount; i++) {
      const x = Math.floor(Math.random() * cols);
      const y = Math.floor((Math.random() * extendedRows) - padRows); // can be negative

      const s = (Math.random() < 0.15) ? 2 : 1;

      const phase = Math.random() * Math.PI * 2;
      const speed = 0.8 + Math.random() * 1.8;
      const base  = 0.35 + Math.random() * 0.45;
      const amp   = 0.15 + Math.random() * 0.4;

      stars.push({ x, y, s, phase, speed, base, amp });
    }
  }

  // --------- SHOOTING STARS (meteors) ----------
  const shooting = [];
  function spawnShootingStar(time) {
    const w = canvas.width, h = canvas.height;
    const skyH = Math.floor(h * SKY_RATIO);

    const startX = Math.random() * w * 0.6;
    const startY = Math.random() * skyH * 0.55;

    const speed = 900 + Math.random() * 500;
    const angle = Math.PI / 4;
    const vx = Math.cos(angle) * speed;
    const vy = Math.sin(angle) * speed;

    const tail = 120 + Math.random() * 140;
    const life = 0.9 + Math.random() * 0.35;

    shooting.push({ x: startX, y: startY, vx, vy, tail, t0: time, life });
  }

  // --------- CRESCENT MOON (flipped) ----------
  function drawCrescentMoon(skyH) {
    const w = canvas.width;

    const moonX = Math.floor(w * 0.82);
    const moonY = Math.floor(skyH * 0.22);
    const r = Math.floor(Math.min(w, skyH) * 0.055);

    const pr = Math.max(6, Math.floor(r / PX) * PX);
    const cx = Math.floor(moonX / PX);
    const cy = Math.floor(moonY / PX);
    const rr = Math.floor(pr / PX);

    // bright circle
    for (let dy = -rr; dy <= rr; dy++) {
      for (let dx = -rr; dx <= rr; dx++) {
        const d2 = dx*dx + dy*dy;
        if (d2 <= rr*rr) {
          const shade = clamp(1 - (dx + dy) / (rr * 3.2), 0.75, 1.0);
          const v = Math.floor(235 * shade);
          ctx.fillStyle = `rgb(${v},${v},${v})`;
          ctx.fillRect((cx + dx) * PX, (cy + dy) * PX, PX, PX);
        }
      }
    }

    // carve (offset LEFT)
    const cutOffset = Math.floor(rr * 0.45);
    const cutR = Math.floor(rr * 0.98);

    ctx.fillStyle = "#000";
    for (let dy = -cutR; dy <= cutR; dy++) {
      for (let dx = -cutR; dx <= cutR; dx++) {
        const d2 = dx*dx + dy*dy;
        if (d2 <= cutR*cutR) {
          ctx.fillRect((cx + dx - cutOffset) * PX, (cy + dy) * PX, PX, PX);
        }
      }
    }

    // crater dots
    ctx.fillStyle = "rgba(175,175,175,0.85)";
    const craterCount = 7;
    for (let i = 0; i < craterCount; i++) {
      const a = Math.random() * Math.PI * 2;
      const rr2 = Math.random() * (rr * 0.55);
      const dx = Math.floor(Math.cos(a) * rr2);
      const dy = Math.floor(Math.sin(a) * rr2);

      const insideMain = (dx*dx + dy*dy) < rr*rr * 0.92;
      const cutDx = dx + cutOffset;
      const insideCut = (cutDx*cutDx + dy*dy) < cutR*cutR * 0.98;

      if (insideMain && !insideCut) {
        ctx.fillRect((cx + dx) * PX, (cy + dy) * PX, PX, PX);
      }
    }
  }

  // --------- OCEAN DRAW ----------
  function drawOcean(yStartPx, time) {
    const w = canvas.width;
    const h = canvas.height;
    const oceanH = h - yStartPx;

    const cols = Math.ceil(w / PX);
    const rows = Math.ceil(oceanH / PX);

    const swellSpeed = 0.35;
    const rippleSpeed = 0.9;
    const shimmerSpeed = 1.2;

    const bandScaleY = 0.12;
    const rippleScaleY = 0.35;

    const sparkleChance = 0.015;

    for (let y = 0; y < rows; y++) {
      const yn = y / Math.max(1, rows - 1);
      const depth = Math.pow(yn, 1.4);

      const band =
        Math.sin((y * bandScaleY) + time * swellSpeed) * 0.6 +
        Math.sin((y * bandScaleY * 0.7) - time * swellSpeed * 0.8) * 0.4;

      const ripple =
        Math.sin((y * rippleScaleY) + time * rippleSpeed) * 0.35 +
        Math.sin((y * rippleScaleY * 1.9) - time * rippleSpeed * 1.2) * 0.15;

      const shimmer = Math.sin((y * 0.55) - time * shimmerSpeed) * 0.18;

      for (let x = 0; x < cols; x++) {
        const n = smoothNoise(x * 0.15 + time * 0.4, y * 0.2) - 0.5;

        let v = 0.5
          + band * 0.35
          + ripple * 0.25
          + shimmer * 0.22
          + n * 0.22
          + depth * 0.25;

        v = clamp(v, 0, 1);
        let idx = Math.floor(v * (OCEAN_PAL.length - 1));

        const sparkleBias = (yn > 0.25 ? (v > 0.62 ? 1 : 0) : 0);
        if (sparkleBias && hash2(x + Math.floor(time * 12), y + 9999) < sparkleChance) {
          idx = OCEAN_PAL.length - 1;
        }

        ctx.fillStyle = OCEAN_PAL[idx];
        ctx.fillRect(x * PX, yStartPx + y * PX, PX, PX);
      }
    }
  }

  // --------- FALLING STAR SPRITES (separate file) ----------
  const fallingStars = new FallingStarSystem({
    src: "star.png",
    spawnRate: 0.35,
    maxStars: 22,
    minScale: 0.06,   // super small start
    maxScale: 0.55    // grows slower / not massive
  });

  let pendingEnableFallingStars = false;

  // --------- MAIN LOOP ----------
  let last = performance.now();

  function frame(now) {
    const t = now * 0.001;
    const dt = (now - last) / 1000;
    last = now;

    const w = canvas.width;
    const h = canvas.height;
    const skyH = Math.floor(h * SKY_RATIO);

    // Update camera pan
    const u = (t - camT0) / PAN_DURATION;
    if (u >= 0 && u <= 1) {
      const e = easeInOut(u);
      camNowY = lerp(camStartY, camTargetY, e);
    } else {
      camNowY = camTargetY;
    }

    // Enable falling stars only AFTER pan finishes into look-up mode
    if (pendingEnableFallingStars && Math.abs(camNowY - camTargetY) < 0.5) {
      pendingEnableFallingStars = false;
      fallingStars.enable();
    }

    // Move whole scene DOWN (look up)
    ctx.setTransform(1, 0, 0, 1, 0, camNowY);

    // Clear bigger area
    ctx.fillStyle = "#000";
    ctx.fillRect(0, -camNowY - 2, w, h + Math.abs(camNowY) + 4);

    // Twinkle stars
    for (const s of stars) {
      const tw = s.base + s.amp * (0.5 + 0.5 * Math.sin(t * s.speed + s.phase));
      const b = Math.floor(255 * clamp(tw, 0, 1));
      ctx.fillStyle = `rgb(${b},${b},${b})`;
      ctx.fillRect(s.x * PX, s.y * PX, s.s * PX, s.s * PX);
    }

    // Falling sprite stars (only active in look-up mode after pan completes)
    fallingStars.update(dt, w, h, camNowY);
    fallingStars.draw(ctx);

    // Moon
    drawCrescentMoon(skyH);

    // Meteors keep appearing randomly
    if (Math.random() < SHOOTING_CHANCE * dt * 1.2) {
      spawnShootingStar(t);
    }

    // Meteors
    for (let i = shooting.length - 1; i >= 0; i--) {
      const sh = shooting[i];
      const age = t - sh.t0;
      if (age > sh.life) {
        shooting.splice(i, 1);
        continue;
      }

      sh.x += sh.vx * dt;
      sh.y += sh.vy * dt;

      const fade = clamp(1 - age / sh.life, 0, 1);
      const steps = Math.floor(sh.tail / (PX * 1.2));

      for (let k = 0; k < steps; k++) {
        const px = sh.x - (k * PX) * Math.cos(Math.PI / 4);
        const py = sh.y - (k * PX) * Math.sin(Math.PI / 4);

        if (py < -500 || py > h + 500) continue;

        const localFade = fade * (1 - k / steps);
        const b = Math.floor(255 * localFade);
        ctx.fillStyle = `rgb(${b},${b},${b})`;

        const gx = Math.floor(px / PX) * PX;
        const gy = Math.floor(py / PX) * PX;
        ctx.fillRect(gx, gy, PX, PX);
      }
    }

    // Ocean (moves off-screen in look-up mode, but still rendered)
    drawOcean(skyH, t);

    // Reset transform so UI doesn't move
    ctx.setTransform(1, 0, 0, 1, 0, 0);

    requestAnimationFrame(frame);
  }

  initStars();
  requestAnimationFrame(frame);

  window.addEventListener("resize", () => {
    resize();
    initStars();
  });

  // Button click = toggle look up; falling stars ONLY after shift completes into look-up
  catchBtn.addEventListener("click", () => {
    const h = canvas.height;
    const skyH = Math.floor(h * SKY_RATIO);

    const goingToLookUp = (Math.abs(camNowY) < 1);

    startPan(performance.now() * 0.001, skyH, h);

    if (goingToLookUp) {
      pendingEnableFallingStars = true;   // enable after pan completes
    } else {
      pendingEnableFallingStars = false;  // turning back to ocean view
      fallingStars.disable();
    }
  });
</script>
</body>
</html>
