<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pixel Night Ocean</title>
  <style>
    html, body { height: 100%; margin: 0; background: #000; overflow: hidden; }
    canvas {
      width: 100vw;
      height: 100vh;
      display: block;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<script>
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });
  ctx.imageSmoothingEnabled = false;

  // ---------- TWEAK KNOBS ----------
  let PX = 4;                 // pixel size (chunkiness). Try 5 or 6 for chunkier.
  const SKY_RATIO = 0.62;     // how much of the screen is sky (0..1)
  const STAR_COUNT = 110;     // star density
  const SHOOTING_CHANCE = 0.06; // chance to spawn a shooting star each "check"
  // --------------------------------

  // Ocean palette (dark -> highlight)
  const OCEAN_PAL = [
    "#001027",
    "#00183a",
    "#00234f",
    "#002f66",
    "#003a7a",
    "#0a4a8c",
    "#1f63a8",
    "#63a7ff"
  ];

  function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
  function lerp(a, b, t) { return a + (b - a) * t; }

  // Hash noise (fast)
  function hash2(x, y) {
    let n = x * 374761393 + y * 668265263;
    n = (n ^ (n >> 13)) * 1274126177;
    n = n ^ (n >> 16);
    return (n >>> 0) / 4294967296;
  }

  function smoothNoise(x, y) {
    const x0 = Math.floor(x), y0 = Math.floor(y);
    const fx = x - x0, fy = y - y0;
    const n00 = hash2(x0, y0);
    const n10 = hash2(x0 + 1, y0);
    const n01 = hash2(x0, y0 + 1);
    const n11 = hash2(x0 + 1, y0 + 1);
    const nx0 = lerp(n00, n10, fx);
    const nx1 = lerp(n01, n11, fx);
    return lerp(nx0, nx1, fy);
  }

  function resize() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width  = Math.floor(window.innerWidth  * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);

    const minDim = Math.min(window.innerWidth, window.innerHeight);
    PX = minDim < 520 ? 5 : 4;
  }
  window.addEventListener("resize", resize);
  resize();

  // --------- STARFIELD (stored state so it twinkles nicely) ----------
  const stars = [];
  function initStars() {
    stars.length = 0;
    const w = canvas.width, h = canvas.height;
    const skyH = Math.floor(h * SKY_RATIO);
    const cols = Math.ceil(w / PX);
    const rows = Math.ceil(skyH / PX);

    for (let i = 0; i < STAR_COUNT; i++) {
      const x = Math.floor(Math.random() * cols);
      const y = Math.floor(Math.random() * rows);

      // A tiny variety in star size (1px or 2px in pixel units)
      const s = (Math.random() < 0.15) ? 2 : 1;

      // Each star gets its own twinkle speed/phase
      const phase = Math.random() * Math.PI * 2;
      const speed = 0.8 + Math.random() * 1.8; // twinkle speed
      const base  = 0.35 + Math.random() * 0.45; // base brightness
      const amp   = 0.15 + Math.random() * 0.4;  // twinkle amplitude

      stars.push({ x, y, s, phase, speed, base, amp });
    }
  }

  // --------- SHOOTING STARS ----------
  const shooting = [];
  function spawnShootingStar(time) {
    const w = canvas.width, h = canvas.height;
    const skyH = Math.floor(h * SKY_RATIO);

    // Start somewhere near top-left-ish, travel down-right
    const startX = Math.random() * w * 0.6;
    const startY = Math.random() * skyH * 0.5;

    // Velocity (in pixels per second)
    const speed = 900 + Math.random() * 500;
    const angle = Math.PI / 4; // 45 degrees
    const vx = Math.cos(angle) * speed;
    const vy = Math.sin(angle) * speed;

    // Tail length in pixels
    const tail = 120 + Math.random() * 140;

    // Lifetime
    const life = 0.9 + Math.random() * 0.35;

    shooting.push({
      x: startX, y: startY,
      vx, vy, tail,
      t0: time, life
    });
  }

  // --------- MOON ----------
  // Pixel moon position (in screen pixels)
  function drawMoon(skyH) {
    const w = canvas.width;

    const moonX = Math.floor(w * 0.82);
    const moonY = Math.floor(skyH * 0.22);
    const r = Math.floor(Math.min(w, skyH) * 0.055); // radius
    const pr = Math.max(6, Math.floor(r / PX) * PX); // quantize-ish

    // draw as chunky "pixel circle"
    const cx = Math.floor(moonX / PX);
    const cy = Math.floor(moonY / PX);
    const rr = Math.floor(pr / PX);

    for (let dy = -rr; dy <= rr; dy++) {
      for (let dx = -rr; dx <= rr; dx++) {
        const d2 = dx*dx + dy*dy;
        if (d2 <= rr*rr) {
          // slight shading: brighter on top-left
          const shade = clamp(1 - (dx + dy) / (rr * 3.2), 0.75, 1.0);
          const v = Math.floor(230 * shade); // grayscale
          ctx.fillStyle = `rgb(${v},${v},${v})`;
          ctx.fillRect((cx + dx) * PX, (cy + dy) * PX, PX, PX);
        }
      }
    }

    // small "craters" using darker dots
    ctx.fillStyle = "rgba(160,160,160,0.9)";
    const craterCount = 10;
    for (let i = 0; i < craterCount; i++) {
      const a = Math.random() * Math.PI * 2;
      const rr2 = Math.random() * (rr * 0.65);
      const dx = Math.floor(Math.cos(a) * rr2);
      const dy = Math.floor(Math.sin(a) * rr2);
      // only place if inside circle
      if (dx*dx + dy*dy < rr*rr * 0.9) {
        ctx.fillRect((cx + dx) * PX, (cy + dy) * PX, PX, PX);
      }
    }
  }

  // --------- OCEAN DRAW ----------
  function drawOcean(yStartPx, time) {
    const w = canvas.width;
    const h = canvas.height;
    const oceanH = h - yStartPx;

    const cols = Math.ceil(w / PX);
    const rows = Math.ceil(oceanH / PX);

    const swellSpeed = 0.35;
    const rippleSpeed = 0.9;
    const shimmerSpeed = 1.2;

    const bandScaleY = 0.12;
    const rippleScaleY = 0.35;

    const sparkleChance = 0.015;

    for (let y = 0; y < rows; y++) {
      const yn = y / Math.max(1, rows - 1);
      const depth = Math.pow(yn, 1.4);

      const band =
        Math.sin((y * bandScaleY) + time * swellSpeed) * 0.6 +
        Math.sin((y * bandScaleY * 0.7) - time * swellSpeed * 0.8) * 0.4;

      const ripple =
        Math.sin((y * rippleScaleY) + time * rippleSpeed) * 0.35 +
        Math.sin((y * rippleScaleY * 1.9) - time * rippleSpeed * 1.2) * 0.15;

      const shimmer = Math.sin((y * 0.55) - time * shimmerSpeed) * 0.18;

      for (let x = 0; x < cols; x++) {
        const n = smoothNoise(x * 0.15 + time * 0.4, y * 0.2) - 0.5;

        let v = 0.5
          + band * 0.35
          + ripple * 0.25
          + shimmer * 0.22
          + n * 0.22
          + depth * 0.25;

        v = clamp(v, 0, 1);

        let idx = Math.floor(v * (OCEAN_PAL.length - 1));

        const sparkleBias = (yn > 0.25 ? (v > 0.62 ? 1 : 0) : 0);
        if (sparkleBias && hash2(x + Math.floor(time * 12), y + 9999) < sparkleChance) {
          idx = OCEAN_PAL.length - 1;
        }

        ctx.fillStyle = OCEAN_PAL[idx];
        ctx.fillRect(x * PX, yStartPx + y * PX, PX, PX);
      }
    }
  }

  // --------- MAIN LOOP ----------
  let last = performance.now();

  function frame(now) {
    const t = now * 0.001;
    const dt = (now - last) / 1000;
    last = now;

    const w = canvas.width;
    const h = canvas.height;
    const skyH = Math.floor(h * SKY_RATIO);

    // Clear screen
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, w, h);

    // SKY: draw twinkling stars
    // (stars are placed on a pixel grid; brightness changes per frame)
    for (const s of stars) {
      const tw = s.base + s.amp * (0.5 + 0.5 * Math.sin(t * s.speed + s.phase));
      const b = Math.floor(255 * clamp(tw, 0, 1));
      ctx.fillStyle = `rgb(${b},${b},${b})`;
      ctx.fillRect(s.x * PX, s.y * PX, s.s * PX, s.s * PX);
    }

    // Moon
    drawMoon(skyH);

    // Shooting stars: spawn sometimes (random checks)
    // We do a check every ~1.2s on average (but depends on dt)
    if (Math.random() < SHOOTING_CHANCE * dt * 1.2) {
      spawnShootingStar(t);
    }

    // Update + draw shooting stars
    for (let i = shooting.length - 1; i >= 0; i--) {
      const sh = shooting[i];
      const age = t - sh.t0;
      if (age > sh.life) {
        shooting.splice(i, 1);
        continue;
      }

      // Move
      sh.x += sh.vx * dt;
      sh.y += sh.vy * dt;

      // Draw as chunky diagonal line + tail (pixelated)
      // Fade out near end
      const fade = clamp(1 - age / sh.life, 0, 1);

      const steps = Math.floor(sh.tail / (PX * 1.2));
      for (let k = 0; k < steps; k++) {
        const px = sh.x - (k * PX) * Math.cos(Math.PI / 4);
        const py = sh.y - (k * PX) * Math.sin(Math.PI / 4);

        if (py < 0 || py > skyH + 50) continue;

        // tail fades
        const localFade = fade * (1 - k / steps);
        const b = Math.floor(255 * localFade);
        ctx.fillStyle = `rgb(${b},${b},${b})`;

        // snap to pixel grid
        const gx = Math.floor(px / PX) * PX;
        const gy = Math.floor(py / PX) * PX;

        ctx.fillRect(gx, gy, PX, PX);
      }
    }

    // Ocean below sky
    drawOcean(skyH, t);

    requestAnimationFrame(frame);
  }

  initStars();
  requestAnimationFrame(frame);

  // Re-init stars on resize so they stay nicely distributed
  window.addEventListener("resize", () => {
    resize();
    initStars();
  });
</script>
</body>
</html>
